#include "front.c"

//Function Declarations

void expr();
void term();
void factor();
void ifstmt();
void error();

/******************************************************/
/* main driver */
main()
{
    /* Open the input data file and process its contents */
    if ((in_fp = fopen("front.in", "r")) == NULL)
        printf("ERROR - cannot open front.in \n");
    else
    {
        getChar();
        do
        {
            lex();
            expr();

        } while (nextToken != EOF);
    }
}
/*****************************************************/
void error()
{
    printf("Error!");
}
/* expr
    Parses strings in the language generated by the rule:
    <expr> -> <term> {(+ | -) <term>}
*/
void expr()
{
    printf("Enter <expr>\n");
    /* Parse the first term */
    term();
    /* As long as the next token is + or -, get
                      the next token and parse the next term */
    while (nextToken == ADD_OP || nextToken == SUB_OP)
    {
        lex();
        term();
    }
    printf("Exit <expr>\n");
} /* End of function expr */
/* term
   Parses strings in the language generated by the rule:
   <term> -> <factor> {(* | /) <factor>)
   */
void term()
{
    printf("Enter <term>\n");
    /* Parse the first factor */
    factor();
    /* As long as the next token is * or /, get the
   next token and parse the next factor */
    while (nextToken == MULT_OP || nextToken == DIV_OP)
    {
        lex();
        factor();
    }
    printf("Exit <term>\n");
} /* End of function term */
/* factor
   Parses strings in the language generated by the rule:
   <factor> -> id | int_constant | ( <expr )
   */
void factor()
{
    printf("Enter <factor>\n");
    /* Determine which RHS */
    if (nextToken == IDENT || nextToken == INT_LIT)
        /* Get the next token */
        lex();
    /* If the RHS is ( <expr>), call lex to pass over the
                      left parenthesis, call expr, and check for the right
                      parenthesis */
    else
    {
        if (nextToken == LEFT_PAREN)
        {
            lex();
            expr();
            if (nextToken == RIGHT_PAREN)
                lex();
            else
                error();
        } /* End of if (nextToken == ... */
          /* It was not an id, an integer literal, or a left
                      parenthesis */
        else
            error();
    } /* End of else */
    printf("Exit <factor>\n");
    ;
} /* End of function factor */
  /* Function ifstmt
    Parses strings in the language generated by the rule:
    <ifstmt> -> if (<boolexpr>) <statement>
                   [else <statement>]
*/
  // void ifstmt()
  // {
  //     /* Be sure the first token is 'if' */
  //     if (nextToken != IF_CODE)
  //         error();
  //     else
  //     {
  //         /* Call lex to get to the next token */
  //         lex();
  //         /* Check for the left parenthesis */
  //         if (nextToken != LEFT_PAREN)
  //             error();
  //         else
  //         {
  //             /* Parse the Boolean expression */
  //             boolexpr();
  //             /* Check for the right parenthesis */ if (nextToken != RIGHT_PAREN)
  //                 error();
  //             else
  //             {
  //                 /* Parse the then clause */
  //                 statement();
  //                 /* If an else is next, parse the else clause */ if (nextToken == ELSE_CODE)
  //                 {
  //                     /* Call lex to get over the else */
  //                     lex();
  //                     statement();
  //                 } /* end of if (nextToken == ELSE_CODE ... */
  //             }     /* end of else of if (nextToken != RIGHT ... */
  //         }         /* end of else of if (nextToken != LEFT ... */
  //     }             /* end of else of if (nextToken != IF_CODE ... */
  // } /* end of ifstmt */